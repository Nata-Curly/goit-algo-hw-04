Результати тестування:

Array size: 10
Merge Sort: 1.4299992471933365e-05
Insertion Sort: 5.2996911108493805e-06
Timsort: 2.00001522898674e-06
----------------------------------------
Array size: 100
Merge Sort: 0.0001055002212524414
Insertion Sort: 0.00012009963393211365
Timsort: 7.700175046920776e-06
----------------------------------------
Array size: 1000
Merge Sort: 0.0012499000877141953
Insertion Sort: 0.018038200214505196
Timsort: 8.640019223093987e-05
----------------------------------------
Array size: 2000
Merge Sort: 0.0032164999283850193
Insertion Sort: 0.09668170008808374
Timsort: 0.0001797000877559185
----------------------------------------
Array size: 5000
Merge Sort: 0.009410700295120478
Insertion Sort: 0.4570193998515606
Timsort: 0.0005064001306891441
----------------------------------------
Array size: 10000
Merge Sort: 0.017902000341564417
Insertion Sort: 1.7840673001483083
Timsort: 0.0010112999007105827
----------------------------------------

Висновки:
Сортування злиттям є найбільш ефективним при незначних розмірах даних, проте при збільшенні розміру масиву (в нашому випадку 2000 та вище) Timsort є найпотужнішим за інші методи сортування. Отже, поєднання сортування злиттям і вставками у Timsort дозволяє ефективно працювати на різних вхідних даних, що робить його вибором за замовчуванням для багатьох задач сортування в мові програмування Python. Це показує важливість оптимізації алгоритмів сортування для реальних застосувань.